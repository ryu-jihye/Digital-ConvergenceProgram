DECLARE
    V_EMPNO NUMBER(4):= 7788;
    V_ENAME VARCHAR2(10);
BEGIN
    V_ENAME:='CONAN';
    DBMS_OUTPUT.PUT_LINE('V_EMPNO:' || V_EMPNO);
    DBMS_OUTPUT.PUT_LINE('V_ENAME:' || V_ENAME);
END;

DECLARE
    V_TAX CONSTANT NUMBER(1):=5;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_TAX:' || V_TAX);
END;

DECLARE
    V_DEPTNO NUMBER(2) DEFAULT 10;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO:' || V_DEPTNO);
END;

--열 참조 : %TYPE, 행 참조 : %ROWTYPE
DECLARE
    V_DEPTNO DEPT.DEPTNO%TYPE:=50;
BEGIN
    DBMS_OUTPUT.PUT_LINE('V_DEPTNO:' || V_DEPTNO);
END;

DECLARE
    V_DEPT_ROW DEPT%ROWTYPE;
BEGIN
    SELECT DEPTNO, DNAME, LOC INTO V_DEPT_ROW
    FROM DEPT
    WHERE DEPTNO = 40;
    DBMS_OUTPUT.PUT_LINE('DEPT:' || V_DEPT_ROW.DEPTNO);
    DBMS_OUTPUT.PUT_LINE('DNAME:' || V_DEPT_ROW.DNAME);
    DBMS_OUTPUT.PUT_LINE('LOC: ' || V_DEPT_ROW.LOC);
END;

DECLARE
    ismale NUMBER(1);
BEGIN
    ismale := &성별;
CASE ismale
    WHEN 1 THEN DBMS_OUTPUT.PUT_LINE('남자');
    WHEN 2 THEN DBMS_OUTPUT.PUT_LINE('여자');
    ELSE DBMS_OUTPUT.PUT_LINE('Third Thing');
    END CASE;
END;

DECLARE 
    i NUMBER:= 0;
BEGIN
    LOOP
    DBMS_OUTPUT.PUT_LINE(i);
    IF i>10 THEN
        EXIT;
    END IF;
    i:=i+1;
    END LOOP;
END;

DECLARE 
    i NUMBER:= 0;
BEGIN
    LOOP
    DBMS_OUTPUT.PUT_LINE(i);
    EXIT WHEN i>10;
    i:=i+1;
    END LOOP;
END;

DECLARE 
    i NUMBER:= 0;
BEGIN
    WHILE i<10 LOOP
    DBMS_OUTPUT.PUT_LINE(i);
   i:=i+1;
   END LOOP;
END;

DECLARE
    i NUMBER:=0;
BEGIN
    FOR i IN REVERSE 1..10 LOOP
    DBMS_OUTPUT.PUT_LINE(i);
    END LOOP;
END;

DECLARE
    V_NUM NUMBER;
BEGIN
    V_NUM:=10/&분모;
EXCEPTION
    WHEN ZERO_DIVIDE THEN
        DBMS_OUTPUT.PUT_LINE('0이외의 다른 값을 입력하시오');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('딴 오류 발생...');
END;

--EXCEPTION
--    WHEN exc_name1 THEN statement1
--    WHEN exc_name2 THEN exc_name3 THEN statement2
--    WHEN OTHERS THEN statement3
--END;

--커서 : 실행 결과 테이블을 한 번에 한 행씩 처리하기 위해 테이블의 행을 순서대로 가리키는데 사용
--조회된 결과값이 여러 개인 경우 효율적
SELECT * FROM MEMBERS;
DESC MEMBERS;

INSERT INTO MEMBERS
VALUES(001, '코난', 'C@CCC.COM', '010-1111-1111', '1111', '2021-01-01');

INSERT INTO MEMBERS
VALUES(002, '장미', 'R@RRR.COM', '010-2222-2222', '2222', '2021-02-02');

INSERT INTO MEMBERS
VALUES(003, '키드', 'K@KKK.COM', '010-3333-3333', '3333', '2021-03-03');

INSERT INTO MEMBERS
VALUES(004, '미란', 'L@LLL.COM', '010-4444-4444', '4444', '2021-04-04');

INSERT INTO MEMBERS
VALUES(005, '인성', 'I@III.COM', '010-5555-5555', '5555', '2021-05-05');

DECLARE
    V_NAME VARCHAR(50);
    V_EMAIL VARCHAR(50);
    --커서 선언
    CURSOR CUR_MEMBER IS SELECT USERNAME, EMAIL FROM MEMBERS;
BEGIN
    --커서 열기
    OPEN CUR_MEMBER;
    --커서로 부터 읽어온 데이터 사용
    FETCH CUR_MEMBER INTO V_NAME, V_EMAIL;
    DBMS_OUTPUT.PUT_LINE(V_NAME);
    DBMS_OUTPUT.PUT_LINE(V_EMAIL);
    --커서 닫기
    CLOSE CUR_MEMBER;
END;

DECLARE
    V_NAME VARCHAR(50);
    V_EMAIL VARCHAR(50);
    --커서 선언
    CURSOR CUR_MEMBER IS SELECT USERNAME, EMAIL FROM MEMBERS;
BEGIN
    --커서 열기
    OPEN CUR_MEMBER;
    LOOP
    --커서로 부터 읽어온 데이터 사용
    FETCH CUR_MEMBER INTO V_NAME, V_EMAIL;
    IF CUR_MEMBER%NOTFOUND THEN --커서의 상태 확인
        EXIT;
    END IF;
    DBMS_OUTPUT.PUT_LINE(V_NAME);
    END LOOP;
    --커서 닫기
    CLOSE CUR_MEMBER;
END;

--익명 프로시저
DECLARE
    V_USERID MEMBERS.USERID%TYPE:='&아이디';
    V_USERPWD MEMBERS.USERPWD%TYPE:='&비밀번호';
    V_MEMBER MEMBERS%ROWTYPE; --MEMBERS가 갖고 있는 레코드 ROWTYPE 한 번에 저장
    --커서 선언
    CURSOR CUR_MEMBER IS SELECT * FROM MEMBERS WHERE USERID=V_USERID;
BEGIN
    --커서 열기
    OPEN CUR_MEMBER;
    FETCH CUR_MEMBER INTO V_MEMBER;
    IF CUR_MEMBER%NOTFOUND THEN --커서의 상태 확인
        DBMS_OUTPUT.PUT_LINE('회원이 존재하지 않음');
    ELSIF V_USERPWD <> V_MEMBER.USERPWD THEN
        DBMS_OUTPUT.PUT_LINE('비밀번호 불일치');
    END IF;
        DBMS_OUTPUT.PUT_LINE('인증 성공');
    --커서 닫기
    CLOSE CUR_MEMBER;
END;

CREATE OR REPLACE PROCEDURE VALIDATE_MEMBER
(
    V_USERID MEMBERS.USERID%TYPE,
    V_USERPWD MEMBERS.USERPWD%TYPE
)
AS 
    V_MEMBER MEMBERS%ROWTYPE;
    CURSOR CUR_MEMBER IS SELECT * FROM MEMBERS WHERE USERID = V_USERID;
BEGIN
    OPEN CUR_MEMBER;
    FETCH CUR_MEMBER INTO V_MEMBER;
        IF CUR_MEMBER%NOTFOUND THEN
            DBMS_OUTPUT.PUT_LINE('회원이 존재하지 않음');
        ELSIF V_USERPWD <> V_MEMBER.USERPWD THEN
            DBMS_OUTPUT.PUT_LINE('비밀번호 불일치');
        ELSE
            DBMS_OUTPUT.PUT_LINE('인증성공');
        END IF;
    CLOSE CUR_MEMBER;
END;

SELECT * FROM BOOK;

CREATE OR REPLACE PROCEDURE INSERTBOOK(
    myBookID IN NUMBER,
    myBookName IN VARCHAR2,
    myPublisher IN VARCHAR2,
    myPrice IN NUMBER)
AS
BEGIN
    INSERT INTO BOOK(BOOKID, BOOKNAME, PUBLISHER, PRICE)
    VALUES(myBookID, myBookName, myPublisher, myPrice);
END;

EXEC INSERTBOOK(19, '백설공주', '디즈니', 22000);
EXEC INSERTBOOK(41, '겨울왕국', '디즈니', 25000);
SELECT * FROM BOOK;

CREATE OR REPLACE PROCEDURE BOOKINSERTORUPDATE
(
    myBookID IN NUMBER,
    myBookName IN VARCHAR2,
    myPublisher IN VARCHAR2,
    myPrice IN NUMBER)
AS 
    mycount NUMBER;
BEGIN
    SELECT COUNT(*) INTO mycount FROM BOOK
    WHERE BOOKNAME LIKE myBookName;
    IF mycount!=0 THEN
        UPDATE BOOK SET PRICE = myPrice
        WHERE BOOKNAME LIKE myBookName;
        ELSE
        INSERT INTO BOOK(BOOKID, BOOKNAME, PUBLISHER, PRICE)
        VALUES(myBookID, myBookName, myPublisher, myPrice);
        END IF;
    CLOSE CUR_MEMBER;
END;

