CREATE TABLE EMP_DDL(
EMPNO NUMBER(4),
ENAME VARCHAR2(10),
JOB VARCHAR2(9),
MGR NUMBER(4),
HIREDATE DATE,
SAL NUMBER(7,2),
COMM NUMBER(7,2),
DEPTNO NUMBER(2)
);

DROP TABLE EMP_DDL;

CREATE TABLE DEPT_DDL
AS SELECT * FROM DEPT;

CREATE TABLE EMP_DDL_30
AS SELECT *
    FROM EMP
    WHERE DEPTNO = 30;

CREATE TABLE EMPDEPT_DDL
AS SELECT
    E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE,
    E.SAL, E.COMM, D.DEPTNO, D.DNAME, D.LOC
    FROM EMP E, DEPT D
    WHERE 1<>1;

CREATE TABLE EMP_ALTER
AS SELECT * FROM EMP;
    
ALTER TABLE EMP_ALTER
ADD HP VARCHAR2(20);

ALTER TABLE EMP_ALTER
RENAME COLUMN HP TO TEL;

ALTER TABLE EMP_ALTER
MODIFY EMPNO NUMBER(10);

ALTER TABLE EMP_ALTER
DROP COLUMN TEL;

RENAME EMP_ALTER TO EMP_RENAME;

TRUNCATE TABLE EMP_RENAME;
DROP TABLE EMP_RENAME;

CREATE TABLE BOOK (
BOOKID NUMBER(2) PRIMARY KEY,
BOOKNAME VARCHAR2(40),
PUBLISHER VARCHAR2(40),
PRICE NUMBER(8)
);

SELECT * FROM BOOK;
SELECT * FROM ORDERS;
SELECT * FROM CUSTOMER;

INSERT INTO CUSTOMER
VALUES(2, '김연아', '대한민국 서울', '000-6000-0001');

INSERT INTO ORDERS VALUES(7, 7, 7, 6000, TO_DATE('2021-04-06', 'YYYY-MM-DD'));

--고객별로 주문한 모든 도서의 총 판매액을 구하고 고객별로 정렬하여 출력하기
SELECT NAME, SUM(SALEPRICE)
FROM CUSTOMER C, ORDERS O
WHERE C.CUSTID = O.CUSTID
GROUP BY C.NAME
ORDER BY C.NAME;

--고객의 이름과 고객이 주문한 도서의 이름 출력하기
SELECT
C.NAME, B.BOOKNAME
FROM CUSTOMER C, BOOK B, ORDERS O
WHERE C.CUSTID = O.CUSTID
        AND O.BOOKID = B.BOOKID;
        
DESC NEWBOOK;
        
--가격이 20000원인 도서를 주문한 고객의 이름과 도서의 이름을 출력하기
SELECT
C.NAME, B.BOOKNAME
FROM CUSTOMER C, BOOK B, ORDERS O
WHERE C.CUSTID = O.CUSTID
        AND O.BOOKID = B.BOOKID
        AND B.PRICE = 20000;
        
 SELECT * FROM NEWBOOK;
-- NULL값을 가질 수 없다 : NOT NULL;
-- PUBLISHER는 같은 값이 있으면 안 된다 : UNIQUE
-- PRICE에 값이 입력되지 않을 경우 기본값 10000 저장,
--가격은 최소 2000원 이상
--: DEFAULT 10000 CHECK(PRICE > 2000)

CREATE TABLE NEWORDERS (
ORDERID NUMBER,
CUSTID NUMBER,
BOOKID NUMBER,
SALEPRICE NUMBER,
ORDERDATE DATE,
PRIMARY KEY (ORDERID),
FOREIGN KEY (CUSTID) REFERENCES NEWCUSTOMER(CUSTID) ON DELETE CASCADE
);

SELECT * FROM NEWBOOK;

SELECT ROWNUM "순번", CUSTID, NAME, PHONE
FROM CUSTOMER
WHERE ROWNUM<=2;

SELECT *
FROM CUSTOMER
WHERE ROWNUM BETWEEN 1 AND 3;

--SCOTT계정에서 사용가능한 데이터 사전
SELECT * FROM DICTIONARY
WHERE TABLE_NAME LIKE 'USER_%';

--현재 오라클에 접속해 있는 사용자가 소유한 객체 정보 보관
SELECT TABLE_NAME
FROM USER_TABLES;

--ALL접두어를 가진 데이터 사전
SELECT OWNER, TABLE_NAME
FROM ALL_TABLES;

--SYSTEM계정으로 DBA 접두어 사용
SELECT * FROM DBA_TABLES;

--SYSTEM 계정으로 사용자 정보 살피기
SELECT *
FROM DBA_USERS
WHERE USERNAME='SCOTT';

SELECT * FROM USER_INDEXES;
SELECT * FROM BOOK;
--인덱스 : 데이터 검색 성능 향상을 위해 테이블 열에 사용하는 객체
CREATE INDEX UNX_BOOK_NAME
ON BOOK(BOOKNAME);

SELECT *
FROM USER_IND_COLUMNS;

DROP INDEX IDX_BOOK_PRICE;
DROP INDEX UNX_BOOK_NAME;


-- VIEW 하나 이상의 테이블을 조회하는 SELECT문 저장(가상 테이블)
SELECT * FROM CUSTOMER;

CREATE VIEW CUSTVIEW
AS SELECT CUSTID, NAME, ADDRESS, PHONE
    FROM CUSTOMER 
    WHERE CUSTID<>2;
    
--시퀀스 : 특정 규칙에 맞는 연속 숫자 생성

select * from dept_sequence;
DROP TABLE DEPT_SEQUENCE;
DROP TABLE SEQ_DEPT_SEQUENCE;

CREATE TABLE DEPT_SEQUENCE
AS SELECT * FROM DEPT
WHERE 1<>1;

SELECT * FROM DEPT_SEQUENCE;

CREATE SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 10
START WITH 10
MAXVALUE 90
MINVALUE 0
NOCYCLE
CACHE 2;

SELECT * FROM USER_SEQUENCES;

INSERT INTO DEPT_SEQUENCE(DEPTNO, DNAME, LOC)
VALUES(SEQ_DEPT_SEQUENCE.NEXTVAL, 'DATABASE', 'SEOUL');

SELECT * FROM DEPT_SEQUENCE;

ALTER SEQUENCE SEQ_DEPT_SEQUENCE
INCREMENT BY 10
MAXVALUE 150
CYCLE;

DROP TABLE DEPT_SEQUENCE;
DROP SEQUENCE SEQ_DEPT_SEQUENCE3;
SELECT * FROM dept_sequence;

--트랜잭션 : 더이상 분할할 수 없는 최소 수행단위, 하나의 작업을 수행하는데 필요한 DB연산 모은 것
--특히 INSERT, DELETE, UPDATE문 실행

SELECT * FROM DEPT_TCL;

INSERT INTO DEPT_TCL VALUES(50, 'DATABASE', 'SEOUL');
INSERT INTO DEPT_TCL VALUES(60, 'RESEARCH', 'INCHEON');
UPDATE DEPT_TCL SET LOC='BUSAN' WHERE DEPTNO=40;
DELETE FROM DEPT_TCL WHERE DNAME='RESEARCH';

SELECT * FROM DEPT_TCL;

ROLLBACK;

COMMIT;

SELECT * FROM DEPT_TCL;

delete from dept_tcl
where deptno = 60;
select * from dept_tcl;

SELECT * FROM TEMP;
DROP TABLE TEMP;

CREATE TABLE TEMP (
    COL1 VARCHAR(20),
    COL2 VARCHAR(20)
);

GRANT SELECT, INSERT ON TEMP
TO C##COFFEE;

REVOKE SELECT, INSERT ON TEMP
FROM C##COFFEE;

--이름이 'WARD'인 사원의 근무일수 출력
SELECT ROUND((SYSDATE-HIREDATE),0) AS "근무일수"
FROM EMP
WHERE ENAME='WARD';

-- 모든 사원이 근무한 지 몇 주가 지났는지 출력
SELECT ENAME AS "이름", ROUND((SYSDATE-HIREDATE),0) AS "근무일수",
ROUND((SYSDATE-HIREDATE)/52,0) AS "근무한 주"
FROM EMP;

-- 각 부서별로 실적에 따라 급여를 다르게 인상 10번과 50번 부서는 각각 10, 20% 인상하고
-- 나머지 부서는 동결할 경우 급여를 출력

SELECT * FROM EMP;

SELECT DEPTNO,
CASE DEPTNO
    WHEN 10 THEN SAL*1.1
    WHEN 50 THEN SAL*1.2
    ELSE SAL*1.0
    END "급여"
FROM EMP;

-- 사원의 이름과 매니저 사번을 출력하시오 
--단, 매니저가 없는 사원의 경우 'TOP'이라고 출력
SELECT * FROM EMP;

SELECT ENAME, MGR,
CASE 
    WHEN MGR IS NULL
    THEN 'TOP'
    ELSE TO_CHAR(MGR)
    END AS MANAGER
FROM EMP;

SELECT * FROM DEPT;
-- 사원의 이름과 매니저 이름, 부서명을 출력하시오 
SELECT E.ENAME, E.MGR, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO;

-- 매월 1, 3주 토요일은 휴무다 현재 월의 휴무일을 출력하라
SELECT DECODE(TO_CHAR(TRUNC(SYSDATE, 'MONTH'), 'D'),
                7,TRUNC(SYSDATE,'MONTH'),
                NEXT_DAY(TRUNC(SYSDATE, 'MONTH'), '토요일')) FIRST,
        DECODE(TO_CHAR(TRUNC(SYSDATE, 'MONTH'), 'D'),
        7,TRUNC(SYSDATE,'MONTH')+14,
                NEXT_DAY(TRUNC(SYSDATE, 'MONTH'), '토요일')+14) THIRD
FROM DUAL;

SELECT * FROM EMP;
SELECT ENAME, COMM, DECODE(COMM, NULL, 'N', 'Y') COMM_YN
FROM EMP
WHERE EMPNO IN('7839', '7566', '7499');

SELECT ENAME, JOB, DECODE(JOB, 'PRESIDENT', '경영자', 
                            'MANAGER', '관리자', 'ANALYST', '분석가') AS "JOB_KOR"
FROM EMP
WHERE EMPNO IN('7839', '7566', '7788');

SELECT * FROM DEPT;
-- 20번 부서의 이름과 그 부서에서 그 근무하는 사원의 이름을 출력하시오
SELECT E.ENAME, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
    AND E.DEPTNO = 20;

SELECT * FROM EMP;
-- 20번 지역의 이름과 그 곳에 있는 부서원 이름을 출력하시오
SELECT D.LOC AS "지역이름", E.ENAME AS "부서원 이름"
FROM DEPT D, EMP E
WHERE D.DEPTNO = E.DEPTNO
    AND E.DEPTNO=20;

  