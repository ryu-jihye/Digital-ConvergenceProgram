SELECT
SUM(DISTINCT SAL),
SUM(ALL SAL),
SUM(SAL)
FROM EMP;

SELECT 
COUNT(*)
FROM EMP
WHERE DEPTNO=30;

SELECT
COUNT(DISTINCT SAL),
COUNT(ALL SAL),
COUNT(SAL)
FROM EMP;

SELECT
COUNT(COMM)
FROM EMP;

SELECT 
COUNT(COMM)
FROM EMP
WHERE COMM IS NOT NULL;

SELECT
MAX(SAL) AS 최대,
MIN(SAL) AS 최소
FROM EMP
WHERE DEPTNO = 10;

SELECT
MAX(HIREDATE) AS 최근입사일,
MIN(HIREDATE) AS 오래된입사일
FROM EMP
WHERE DEPTNO=20;

SELECT
AVG(SAL)
FROM EMP
WHERE DEPTNO=30;

--1)
SELECT
MAX(SAL) AS "MAX",
MIN(SAL) AS "MIN",
SUM(SAL) AS "SAL",
ROUND(AVG(SAL),1) AS "AVG"
FROM EMP;

--2) 업무이름과 업무별로 동일한 업무를 하는 사원의 수를 출력하라
-- 열 이름은 각각 '업무'와 '업무별 사원수'로 출력


--3) 
SELECT
MAX(SAL) - MIN(SAL) AS 차액
FROM EMP;

--4)
SELECT
COUNT(*),
SUM(SAL),
AVG(SAL)
FROM EMP
WHERE DEPTNO=30;

-- 5) 평균 급여가 가장 높은 부서 번호 출력하기
SELECT SAL, DEPTNO
FROM EMP
WHERE AVG(SAL) = MAX(SAL)
GROUP BY SAL, DEPTNO
HAVING DEPTNO = EMP; -- 오류 발생
-- 5) 답
SELECT ROUND(AVG(SAL)) AS "AVG",DEPTNO --5
FROM EMP GROUP BY DEPTNO ORDER BY "AVG" DESC;


SELECT
AVG(SAL), DEPTNO
FROM EMP
GROUP BY DEPTNO;

SELECT 
DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
ORDER BY DEPTNO, JOB;

--★ 중요 ★ -> GROUP BY절에 조건을 줄 때 HAVING 절
SELECT
DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >=2000
ORDER BY DEPTNO, JOB;

SELECT
DEPTNO, JOB, AVG(SAL)
FROM EMP
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;


SELECT 
DEPTNO,JOB, AVG(SAL)
FROM EMP
WHERE SAL <= 3000
GROUP BY DEPTNO, JOB
HAVING AVG(SAL) >= 2000
ORDER BY DEPTNO, JOB;

SELECT * 
FROM EMP;

SELECT * 
FROM EMP, DEPT
WHERE EMP.DEPTNO = DEPT.DEPTNO
ORDER BY EMPNO; --두 테이블의 조인결과로 나올 수 있는 합 중에서 부서 번호가 일치하는 데이터만 출력

--EMP 테이블 별칭을 E로, DEPT 테이블 별칭을 D로 하여 사원번호와 부서 번호 출력하기
SELECT E.EMPNO, D.DNAME
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO;

SELECT * FROM EMP;

SELECT
EMPNO, ENAME, E.DEPTNO, DNAME, LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO
ORDER BY EMPNO;

SELECT
E.EMPNO, E.ENAME, E.SAL, E.DEPTNO, D.DNAME, D.LOC
FROM EMP E, DEPT D
WHERE E.DEPTNO = D.DEPTNO AND SAL >= 3000;

-- 사원들의 급여 등급을 포함한 사원정보 출력하기
SELECT * FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

-- EMP테이블에는 직속상관의 사원번호(MGR)가 저장되어 있음
-- 사원의 이름과 해당 사원의 직속 상관의 이름을 나란히 출력하기
-- SMITH의 상관 사원 번호 : 7902
-- 사원번호가 7902인 사원은 FORD
-- SMITH의 상관은 FORD
SELECT
E.EMPNO, E.ENAME, E.MGR,
M.EMPNO AS MGR_NO,
M.ENAME AS MGR_NAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO;
 
SELECT -- 상사가 없는 직원이 서로 섞여 있음
E.EMPNO, E.ENAME, E.MGR,
M.EMPNO AS MGR_NO,
M.ENAME AS MGR_NAME
FROM EMP E, EMP M
WHERE E.MGR = M.EMPNO(+)
ORDER BY E.EMPNO;

SELECT --NULL값은 밑으로 정렬됨
E.EMPNO, E.ENAME, E.MGR,
M.EMPNO AS MGR_NO,
M.ENAME AS MGR_NAME
FROM EMP E, EMP M
WHERE E.MGR(+) = M.EMPNO
ORDER BY E.EMPNO;

SELECT
E.EMPNO, E.ENAME, E.JOB, E.MGR,
E.HIREDATE, E.SAL, E.COMM,
DEPTNO,
-- 기준열이 DEPTNO를 SELECT절에 명시할 때 테이블에 이름을 붙이면 안 됨
D.DNAME, D.LOC
FROM EMP E NATURAL JOIN DEPT D 
-- NATUAL JOIN : 두 테이블에서 이름과 자료형이 같은 열을 찾은 후 그 열을 기준으로 등가 조인
ORDER BY DEPTNO, E.EMPNO;


SELECT
E.EMPNO, E.ENAME, E.JOB, E.MGR,
E.HIREDATE, E.SAL, E.COMM,
DEPTNO, D.DNAME, D.LOC
FROM EMP E JOIN DEPT D USING(DEPTNO)
WHERE SAL>=3000
ORDER BY DEPTNO, E.EMPNO;

SELECT
E.EMPNO, E.ENAME, E.JOB, E.MGR, E.HIREDATE, E.SAL,
E.COMM,
E.DEPTNO,
D.DNAME, D.LOC
FROM EMP E JOIN DEPT D ON (E.DEPTNO=D.DEPTNO)
WHERE SAL >= 3000
ORDER BY E.DEPTNO, EMPNO;

SELECT -- 상사 정보와 함께 출력(P.20)
E.EMPNO, E.ENAME, E.MGR,
M.EMPNO AS MGR_NO,
M.ENAME AS MGR_NAME
FROM EMP E LEFT OUTER JOIN EMP M ON(E.MGR = M.EMPNO)
ORDER BY E.EMPNO;

SELECT 
E.EMPNO, E.ENAME, E.MGR,
M.EMPNO AS MGR_NO,
M.ENAME AS MGR_NAME
FROM EMP E RIGHT OUTER JOIN EMP M ON(E.MGR = M.EMPNO)
ORDER BY E.EMPNO;